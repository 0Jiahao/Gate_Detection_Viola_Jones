function verifyDroneModelEarthFrame(GT)

predictionStates = zeros(length(GT.TIME),6);

for i = 1:length(GT.TIME)
   if i == 1
       predictionStates(i,:) = [GT.X(i) GT.Y(i) GT.Z(i) GT.VX(i) GT.VY(i) GT.VZ(i)];   
      continue;
   end
   deltaT = GT.TIME(i) - GT.TIME(i-1);
   currentStates = predictionStates(i-1,:);
   currentInputs = [GT.PHI(i) GT.THETA(i) GT.PSI(i) GT.AX(i) GT.AY(i) GT.AZ(i)];
   dx = droneModelEarth(currentStates,currentInputs);
   predictionStates(i,:) = predictionStates(i-1,:) + dx'*deltaT;
end

figure()
subplot(3,1,1)
plot(GT.TIME,GT.X);
hold on
plot(GT.TIME,predictionStates(:,1));
subplot(3,1,2)
plot(GT.TIME,GT.Y);
hold on
plot(GT.TIME,predictionStates(:,2));
subplot(3,1,3)
plot(GT.TIME,GT.Z);
hold on
plot(GT.TIME,predictionStates(:,3));

end

function dx = droneModelEarth(state,input)

vx = state(4);
vy = state(5);
vz = state(6);
phi = input(1);
theta = input(2);
psi = input(3);
AX = input(4);
AY = input(5);
AZ = input(6);

R_E_B = [cos(theta)*cos(psi) cos(theta)*sin(phi) -sin(theta);...
    sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi)...
    sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi) sin(phi)*cos(theta);...
    cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi)...
    cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi) cos(phi)*cos(theta)];
R_B_E = R_E_B';

%dv = [0 0 9.8]'+R_B_E*[0 0 AZ]'+R_B_E*[-0.5 0 0;0 -0.5 0;0 0 -0.5]*R_E_B*[vx vy vz]';
dv = [0 0 9.8]'+R_B_E*[AX AY AZ]';
dx = [vx; vy; vz;dv];
end